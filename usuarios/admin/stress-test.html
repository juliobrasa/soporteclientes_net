<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing de Carga y Stress - Kavia Admin Panel</title>
    
    <!-- CSS Base -->
    <link rel="stylesheet" href="assets/css/admin-base.css">
    <link rel="stylesheet" href="assets/css/admin-components.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f3f4f6;
        }
        
        .stress-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .stress-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .stress-header h1 {
            margin: 0 0 10px 0;
            color: #1f2937;
            font-size: 2.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .stress-header p {
            margin: 0;
            color: #6b7280;
            font-size: 1.1rem;
        }
        
        .test-configs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .config-card {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
        }
        
        .config-title {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .config-group {
            margin-bottom: 15px;
        }
        
        .config-label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 5px;
        }
        
        .config-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .config-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
        }
        
        .test-controls {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .controls-left {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .controls-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .control-btn {
            padding: 10px 20px;
            border: 2px solid white;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover:not(:disabled) {
            background: white;
            color: #667eea;
        }
        
        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .control-btn.active {
            background: white;
            color: #667eea;
        }
        
        .test-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .real-time-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        
        .metric-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #6b7280;
            font-size: 0.9rem;
        }
        
        .metric-change {
            font-size: 0.8rem;
            font-weight: 500;
            margin-top: 5px;
        }
        
        .metric-change.positive {
            color: #10b981;
        }
        
        .metric-change.negative {
            color: #ef4444;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
        }
        
        .chart-title {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chart-canvas {
            width: 100%;
            height: 200px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }
        
        .test-results {
            background: #f9fafb;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
        }
        
        .export-btn {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .result-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #3b82f6;
        }
        
        .result-item.success {
            border-left-color: #10b981;
        }
        
        .result-item.warning {
            border-left-color: #f59e0b;
        }
        
        .result-item.error {
            border-left-color: #ef4444;
        }
        
        .result-metric {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 5px;
        }
        
        .result-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3b82f6;
        }
        
        .result-description {
            font-size: 0.9rem;
            color: #6b7280;
            margin-top: 5px;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .stress-container {
                padding: 20px;
                margin: 10px;
            }
            
            .test-configs {
                grid-template-columns: 1fr;
            }
            
            .test-controls {
                flex-direction: column;
                text-align: center;
            }
            
            .controls-left,
            .controls-right {
                justify-content: center;
            }
            
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .real-time-metrics {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="stress-container">
        <div class="stress-header">
            <h1><i class="fas fa-tachometer-alt"></i> Testing de Carga y Stress</h1>
            <p>Sistema avanzado de testing de rendimiento y escalabilidad</p>
        </div>
        
        <!-- ConfiguraciÃ³n de Tests -->
        <div class="test-configs">
            <div class="config-card">
                <div class="config-title">
                    <i class="fas fa-users"></i>
                    ConfiguraciÃ³n de Carga
                </div>
                <div class="config-group">
                    <label class="config-label">Usuarios Concurrentes</label>
                    <input type="number" class="config-input" id="concurrent-users" value="10" min="1" max="1000">
                </div>
                <div class="config-group">
                    <label class="config-label">DuraciÃ³n (segundos)</label>
                    <input type="number" class="config-input" id="test-duration" value="60" min="10" max="3600">
                </div>
                <div class="config-group">
                    <label class="config-label">Ramp-up (segundos)</label>
                    <input type="number" class="config-input" id="ramp-up" value="10" min="1" max="300">
                </div>
            </div>
            
            <div class="config-card">
                <div class="config-title">
                    <i class="fas fa-bullseye"></i>
                    Endpoints a Testear
                </div>
                <div class="config-group">
                    <label class="config-label">MÃ³dulo Principal</label>
                    <select class="config-select" id="test-module">
                        <option value="all">Todos los mÃ³dulos</option>
                        <option value="hotels">Hoteles</option>
                        <option value="providers">Proveedores IA</option>
                        <option value="apis">APIs Externas</option>
                        <option value="extraction">ExtracciÃ³n</option>
                        <option value="prompts">Prompts</option>
                        <option value="logs">Logs</option>
                    </select>
                </div>
                <div class="config-group">
                    <label class="config-label">Tipo de Test</label>
                    <select class="config-select" id="test-type">
                        <option value="load">Test de Carga</option>
                        <option value="stress">Test de Stress</option>
                        <option value="spike">Test de Picos</option>
                        <option value="volume">Test de Volumen</option>
                    </select>
                </div>
            </div>
            
            <div class="config-card">
                <div class="config-title">
                    <i class="fas fa-sliders-h"></i>
                    ParÃ¡metros Avanzados
                </div>
                <div class="config-group">
                    <label class="config-label">Delay entre requests (ms)</label>
                    <input type="number" class="config-input" id="request-delay" value="100" min="0" max="5000">
                </div>
                <div class="config-group">
                    <label class="config-label">Timeout (ms)</label>
                    <input type="number" class="config-input" id="request-timeout" value="5000" min="1000" max="30000">
                </div>
                <div class="config-group">
                    <label class="config-label">Think Time (ms)</label>
                    <input type="number" class="config-input" id="think-time" value="1000" min="0" max="10000">
                </div>
            </div>
        </div>
        
        <!-- Controles de Test -->
        <div class="test-controls">
            <div class="controls-left">
                <button class="control-btn" id="start-test" onclick="startStressTest()">
                    <i class="fas fa-play"></i> Iniciar Test
                </button>
                <button class="control-btn" id="pause-test" onclick="pauseStressTest()" disabled>
                    <i class="fas fa-pause"></i> Pausar
                </button>
                <button class="control-btn" id="stop-test" onclick="stopStressTest()" disabled>
                    <i class="fas fa-stop"></i> Detener
                </button>
                <button class="control-btn" onclick="resetTest()">
                    <i class="fas fa-redo"></i> Reset
                </button>
            </div>
            <div class="controls-right">
                <div class="test-status">
                    <div class="status-indicator" id="status-indicator" style="background: #6b7280; animation: none;"></div>
                    <span id="test-status-text">Listo para iniciar</span>
                </div>
            </div>
        </div>
        
        <!-- MÃ©tricas en Tiempo Real -->
        <div class="real-time-metrics">
            <div class="metric-card">
                <div class="metric-icon" style="color: #3b82f6;">
                    <i class="fas fa-bolt"></i>
                </div>
                <div class="metric-value" id="current-rps">0</div>
                <div class="metric-label">Requests/seg</div>
                <div class="metric-change" id="rps-change">--</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-icon" style="color: #10b981;">
                    <i class="fas fa-clock"></i>
                </div>
                <div class="metric-value" id="avg-response-time">0ms</div>
                <div class="metric-label">Tiempo Promedio</div>
                <div class="metric-change" id="time-change">--</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-icon" style="color: #f59e0b;">
                    <i class="fas fa-users"></i>
                </div>
                <div class="metric-value" id="active-users">0</div>
                <div class="metric-label">Usuarios Activos</div>
                <div class="metric-change" id="users-change">--</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-icon" style="color: #ef4444;">
                    <i class="fas fa-exclamation-triangle"></i>
                </div>
                <div class="metric-value" id="error-rate">0%</div>
                <div class="metric-label">Tasa de Errores</div>
                <div class="metric-change" id="error-change">--</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-icon" style="color: #8b5cf6;">
                    <i class="fas fa-chart-line"></i>
                </div>
                <div class="metric-value" id="throughput">0</div>
                <div class="metric-label">Throughput</div>
                <div class="metric-change" id="throughput-change">--</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-icon" style="color: #06b6d4;">
                    <i class="fas fa-memory"></i>
                </div>
                <div class="metric-value" id="memory-usage">0MB</div>
                <div class="metric-label">Uso Memoria</div>
                <div class="metric-change" id="memory-change">--</div>
            </div>
        </div>
        
        <!-- GrÃ¡ficos en Tiempo Real -->
        <div class="charts-container">
            <div class="chart-card">
                <div class="chart-title">
                    <i class="fas fa-chart-line"></i>
                    Tiempo de Respuesta
                </div>
                <canvas class="chart-canvas" id="response-time-chart"></canvas>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <i class="fas fa-chart-bar"></i>
                    Requests por Segundo
                </div>
                <canvas class="chart-canvas" id="rps-chart"></canvas>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <i class="fas fa-chart-pie"></i>
                    DistribuciÃ³n de Errores
                </div>
                <canvas class="chart-canvas" id="error-chart"></canvas>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">
                    <i class="fas fa-chart-area"></i>
                    Usuarios Concurrentes
                </div>
                <canvas class="chart-canvas" id="users-chart"></canvas>
            </div>
        </div>
        
        <!-- Resultados del Test -->
        <div class="test-results">
            <div class="results-header">
                <div class="results-title">Resultados del Test</div>
                <button class="export-btn" onclick="exportResults()">
                    <i class="fas fa-download"></i> Exportar
                </button>
            </div>
            
            <div class="results-grid" id="results-grid">
                <!-- Se llenan dinÃ¡micamente -->
            </div>
        </div>
    </div>
    
    <script>
        /**
         * Sistema de Testing de Carga y Stress
         */
        class StressTester {
            constructor() {
                this.isRunning = false;
                this.isPaused = false;
                this.testStartTime = null;
                this.activeUsers = 0;
                this.totalRequests = 0;
                this.successfulRequests = 0;
                this.failedRequests = 0;
                this.responseTimes = [];
                this.currentRPS = 0;
                this.testInterval = null;
                this.metricsInterval = null;
                this.charts = {};
                this.testData = {
                    responseTime: [],
                    rps: [],
                    errors: [],
                    users: []
                };
                
                this.endpoints = {
                    all: [
                        'admin_api.php?action=getHotels',
                        'admin_api.php?action=getProviders', 
                        'admin_api.php?action=getExternalApis',
                        'admin_api.php?action=getExtractionJobs',
                        'admin_api.php?action=getPrompts',
                        'admin_api.php?action=getLogs'
                    ],
                    hotels: ['admin_api.php?action=getHotels', 'admin_api.php?action=getHotelStats'],
                    providers: ['admin_api.php?action=getProviders', 'admin_api.php?action=getProviderStats'],
                    apis: ['admin_api.php?action=getExternalApis', 'admin_api.php?action=getApiStats'],
                    extraction: ['admin_api.php?action=getExtractionJobs'],
                    prompts: ['admin_api.php?action=getPrompts', 'admin_api.php?action=getPromptsStats'],
                    logs: ['admin_api.php?action=getLogs', 'admin_api.php?action=getLogsStats']
                };
                
                this.init();
            }
            
            init() {
                console.log('ð Inicializando Sistema de Stress Testing...');
                this.initializeCharts();
                this.updateDisplay();
            }
            
            initializeCharts() {
                // Inicializar grÃ¡ficos con canvas bÃ¡sico
                this.charts.responseTime = document.getElementById('response-time-chart');
                this.charts.rps = document.getElementById('rps-chart');
                this.charts.errors = document.getElementById('error-chart');
                this.charts.users = document.getElementById('users-chart');
                
                // Configurar contextos de canvas
                Object.keys(this.charts).forEach(chartKey => {
                    const canvas = this.charts[chartKey];
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#f3f4f6';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '14px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText('Esperando datos...', canvas.width/2, canvas.height/2);
                });
            }
            
            async startStressTest() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.isPaused = false;
                this.testStartTime = Date.now();
                this.resetMetrics();
                
                // Actualizar UI
                this.updateControlButtons();
                this.updateStatus('Iniciando test...', '#f59e0b');
                
                // ConfiguraciÃ³n del test
                const config = this.getTestConfig();
                console.log('ð Iniciando test con configuraciÃ³n:', config);
                
                // Simular ramp-up de usuarios
                await this.rampUpUsers(config);
                
                // Iniciar mÃ©tricas en tiempo real
                this.startMetricsCollection();
                
                // Ejecutar test principal
                await this.runMainTest(config);
                
                this.completeTest();
            }
            
            getTestConfig() {
                return {
                    concurrentUsers: parseInt(document.getElementById('concurrent-users').value),
                    duration: parseInt(document.getElementById('test-duration').value) * 1000,
                    rampUp: parseInt(document.getElementById('ramp-up').value) * 1000,
                    module: document.getElementById('test-module').value,
                    testType: document.getElementById('test-type').value,
                    requestDelay: parseInt(document.getElementById('request-delay').value),
                    timeout: parseInt(document.getElementById('request-timeout').value),
                    thinkTime: parseInt(document.getElementById('think-time').value)
                };
            }
            
            async rampUpUsers(config) {
                this.updateStatus('Ramping up users...', '#3b82f6');
                
                const usersPerSecond = config.concurrentUsers / (config.rampUp / 1000);
                const rampUpSteps = Math.ceil(config.rampUp / 1000);
                
                for (let i = 0; i < rampUpSteps && this.isRunning; i++) {
                    this.activeUsers = Math.min(
                        Math.ceil(usersPerSecond * (i + 1)), 
                        config.concurrentUsers
                    );
                    this.updateDisplay();
                    await this.sleep(1000);
                }
            }
            
            async runMainTest(config) {
                this.updateStatus('Ejecutando test...', '#10b981');
                
                const endTime = Date.now() + config.duration;
                const endpoints = this.endpoints[config.module];
                
                while (Date.now() < endTime && this.isRunning && !this.isPaused) {
                    // Simular requests concurrentes
                    const promises = [];
                    for (let i = 0; i < this.activeUsers; i++) {
                        promises.push(this.makeRequest(endpoints, config));
                    }
                    
                    await Promise.all(promises);
                    await this.sleep(config.requestDelay);
                }
            }
            
            async makeRequest(endpoints, config) {
                const startTime = Date.now();
                const endpoint = endpoints[Math.floor(Math.random() * endpoints.length)];
                
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), config.timeout);
                    
                    const response = await fetch(endpoint, {
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    
                    this.totalRequests++;
                    
                    if (response.ok) {
                        this.successfulRequests++;
                        this.responseTimes.push(responseTime);
                    } else {
                        this.failedRequests++;
                    }
                    
                } catch (error) {
                    const endTime = Date.now();
                    const responseTime = endTime - startTime;
                    
                    this.totalRequests++;
                    this.failedRequests++;
                    this.responseTimes.push(responseTime);
                }
                
                // Think time
                if (config.thinkTime > 0) {
                    await this.sleep(config.thinkTime);
                }
            }
            
            startMetricsCollection() {
                this.metricsInterval = setInterval(() => {
                    this.updateMetrics();
                    this.updateCharts();
                }, 1000);
            }
            
            updateMetrics() {
                // Calcular RPS
                const elapsed = (Date.now() - this.testStartTime) / 1000;
                this.currentRPS = elapsed > 0 ? Math.round(this.totalRequests / elapsed) : 0;
                
                // Calcular tiempo promedio de respuesta
                const avgResponseTime = this.responseTimes.length > 0 ? 
                    Math.round(this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length) : 0;
                
                // Calcular tasa de errores
                const errorRate = this.totalRequests > 0 ? 
                    Math.round((this.failedRequests / this.totalRequests) * 100) : 0;
                
                // Actualizar datos para grÃ¡ficos
                this.testData.responseTime.push(avgResponseTime);
                this.testData.rps.push(this.currentRPS);
                this.testData.errors.push(errorRate);
                this.testData.users.push(this.activeUsers);
                
                // Limitar arrays para performance
                if (this.testData.responseTime.length > 100) {
                    Object.keys(this.testData).forEach(key => {
                        this.testData[key] = this.testData[key].slice(-100);
                    });
                }
                
                // Simular uso de memoria (en producciÃ³n vendrÃ­a del servidor)
                const memoryUsage = Math.round(64 + Math.random() * 128); // 64-192MB
                
                // Actualizar display
                document.getElementById('current-rps').textContent = this.currentRPS;
                document.getElementById('avg-response-time').textContent = avgResponseTime + 'ms';
                document.getElementById('active-users').textContent = this.activeUsers;
                document.getElementById('error-rate').textContent = errorRate + '%';
                document.getElementById('throughput').textContent = Math.round(this.currentRPS * 1.5);
                document.getElementById('memory-usage').textContent = memoryUsage + 'MB';
            }
            
            updateCharts() {
                // Actualizar grÃ¡fico de tiempo de respuesta
                this.drawLineChart(this.charts.responseTime, this.testData.responseTime, '#3b82f6', 'ms');
                
                // Actualizar grÃ¡fico de RPS
                this.drawLineChart(this.charts.rps, this.testData.rps, '#10b981', 'req/s');
                
                // Actualizar grÃ¡fico de usuarios
                this.drawAreaChart(this.charts.users, this.testData.users, '#8b5cf6', 'users');
                
                // Actualizar grÃ¡fico de errores
                this.drawBarChart(this.charts.errors, this.testData.errors, '#ef4444', '%');
            }
            
            drawLineChart(canvas, data, color, unit) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Limpiar canvas
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f9fafb';
                ctx.fillRect(0, 0, width, height);
                
                if (data.length < 2) return;
                
                // Calcular escalas
                const maxValue = Math.max(...data);
                const minValue = Math.min(...data);
                const range = maxValue - minValue;
                const scaleY = range > 0 ? (height - 40) / range : 1;
                const scaleX = (width - 40) / (data.length - 1);
                
                // Dibujar lÃ­nea
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((value, index) => {
                    const x = 20 + index * scaleX;
                    const y = height - 20 - (value - minValue) * scaleY;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Mostrar valor actual
                if (data.length > 0) {
                    ctx.fillStyle = color;
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${data[data.length - 1]}${unit}`, width - 10, 15);
                }
            }
            
            drawAreaChart(canvas, data, color, unit) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f9fafb';
                ctx.fillRect(0, 0, width, height);
                
                if (data.length < 2) return;
                
                const maxValue = Math.max(...data);
                const scaleY = maxValue > 0 ? (height - 40) / maxValue : 1;
                const scaleX = (width - 40) / (data.length - 1);
                
                // Crear gradiente
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, color + '40');
                gradient.addColorStop(1, color + '10');
                
                // Dibujar Ã¡rea
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(20, height - 20);
                
                data.forEach((value, index) => {
                    const x = 20 + index * scaleX;
                    const y = height - 20 - value * scaleY;
                    ctx.lineTo(x, y);
                });
                
                ctx.lineTo(width - 20, height - 20);
                ctx.closePath();
                ctx.fill();
                
                // Dibujar lÃ­nea superior
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((value, index) => {
                    const x = 20 + index * scaleX;
                    const y = height - 20 - value * scaleY;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }
            
            drawBarChart(canvas, data, color, unit) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f9fafb';
                ctx.fillRect(0, 0, width, height);
                
                if (data.length === 0) return;
                
                const maxValue = Math.max(...data);
                const scaleY = maxValue > 0 ? (height - 40) / maxValue : 1;
                const barWidth = (width - 40) / data.length * 0.8;
                const barSpacing = (width - 40) / data.length;
                
                ctx.fillStyle = color + '80';
                
                data.forEach((value, index) => {
                    const x = 20 + index * barSpacing + barSpacing * 0.1;
                    const barHeight = value * scaleY;
                    const y = height - 20 - barHeight;
                    
                    ctx.fillRect(x, y, barWidth, barHeight);
                });
            }
            
            pauseStressTest() {
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('pause-test');
                
                if (this.isPaused) {
                    btn.innerHTML = '<i class="fas fa-play"></i> Reanudar';
                    this.updateStatus('Test pausado', '#f59e0b');
                } else {
                    btn.innerHTML = '<i class="fas fa-pause"></i> Pausar';
                    this.updateStatus('Test reanudado', '#10b981');
                }
            }
            
            stopStressTest() {
                this.isRunning = false;
                this.isPaused = false;
                this.completeTest();
            }
            
            completeTest() {
                this.isRunning = false;
                
                // Limpiar intervalos
                if (this.testInterval) clearInterval(this.testInterval);
                if (this.metricsInterval) clearInterval(this.metricsInterval);
                
                this.updateControlButtons();
                this.updateStatus('Test completado', '#10b981');
                this.generateResults();
            }
            
            resetTest() {
                this.stopStressTest();
                this.resetMetrics();
                this.updateDisplay();
                this.updateStatus('Listo para iniciar', '#6b7280');
                
                // Limpiar grÃ¡ficos
                this.testData = {
                    responseTime: [],
                    rps: [],
                    errors: [],
                    users: []
                };
                this.initializeCharts();
                
                // Limpiar resultados
                document.getElementById('results-grid').innerHTML = '';
            }
            
            resetMetrics() {
                this.activeUsers = 0;
                this.totalRequests = 0;
                this.successfulRequests = 0;
                this.failedRequests = 0;
                this.responseTimes = [];
                this.currentRPS = 0;
            }
            
            updateControlButtons() {
                const startBtn = document.getElementById('start-test');
                const pauseBtn = document.getElementById('pause-test');
                const stopBtn = document.getElementById('stop-test');
                
                startBtn.disabled = this.isRunning;
                pauseBtn.disabled = !this.isRunning;
                stopBtn.disabled = !this.isRunning;
                
                if (!this.isRunning) {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pausar';
                }
            }
            
            updateStatus(text, color) {
                document.getElementById('test-status-text').textContent = text;
                const indicator = document.getElementById('status-indicator');
                indicator.style.background = color;
                indicator.style.animation = this.isRunning ? 'pulse 2s infinite' : 'none';
            }
            
            updateDisplay() {
                // Las mÃ©tricas se actualizan en updateMetrics()
            }
            
            generateResults() {
                const duration = (Date.now() - this.testStartTime) / 1000;
                const avgResponseTime = this.responseTimes.length > 0 ? 
                    this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length : 0;
                const errorRate = this.totalRequests > 0 ? 
                    (this.failedRequests / this.totalRequests) * 100 : 0;
                
                const results = [
                    {
                        metric: 'DuraciÃ³n Total',
                        value: Math.round(duration) + 's',
                        description: 'Tiempo total de ejecuciÃ³n del test',
                        status: 'success'
                    },
                    {
                        metric: 'Requests Totales',
                        value: this.totalRequests,
                        description: 'NÃºmero total de requests enviados',
                        status: 'success'
                    },
                    {
                        metric: 'Requests Exitosos',
                        value: this.successfulRequests,
                        description: 'Requests que retornaron respuesta vÃ¡lida',
                        status: 'success'
                    },
                    {
                        metric: 'Tasa de Errores',
                        value: errorRate.toFixed(2) + '%',
                        description: 'Porcentaje de requests fallidos',
                        status: errorRate > 5 ? 'error' : errorRate > 1 ? 'warning' : 'success'
                    },
                    {
                        metric: 'Tiempo Promedio',
                        value: Math.round(avgResponseTime) + 'ms',
                        description: 'Tiempo promedio de respuesta',
                        status: avgResponseTime > 2000 ? 'error' : avgResponseTime > 1000 ? 'warning' : 'success'
                    },
                    {
                        metric: 'RPS Promedio',
                        value: this.currentRPS,
                        description: 'Requests por segundo promedio',
                        status: 'success'
                    },
                    {
                        metric: 'Throughput',
                        value: Math.round(this.totalRequests / duration) + ' req/s',
                        description: 'Throughput real del sistema',
                        status: 'success'
                    },
                    {
                        metric: 'Usuarios MÃ¡ximos',
                        value: Math.max(...this.testData.users),
                        description: 'MÃ¡ximo nÃºmero de usuarios concurrentes',
                        status: 'success'
                    }
                ];
                
                this.renderResults(results);
            }
            
            renderResults(results) {
                const grid = document.getElementById('results-grid');
                grid.innerHTML = '';
                
                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = `result-item ${result.status}`;
                    
                    item.innerHTML = `
                        <div class="result-metric">${result.metric}</div>
                        <div class="result-value">${result.value}</div>
                        <div class="result-description">${result.description}</div>
                    `;
                    
                    grid.appendChild(item);
                });
            }
            
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Inicializar stress tester
        let stressTester;
        
        document.addEventListener('DOMContentLoaded', () => {
            stressTester = new StressTester();
        });
        
        // Funciones globales
        function startStressTest() {
            stressTester.startStressTest();
        }
        
        function pauseStressTest() {
            stressTester.pauseStressTest();
        }
        
        function stopStressTest() {
            stressTester.stopStressTest();
        }
        
        function resetTest() {
            stressTester.resetTest();
        }
        
        function exportResults() {
            // Implementar exportaciÃ³n de resultados
            const data = {
                timestamp: new Date().toISOString(),
                config: stressTester.getTestConfig(),
                metrics: {
                    totalRequests: stressTester.totalRequests,
                    successfulRequests: stressTester.successfulRequests,
                    failedRequests: stressTester.failedRequests,
                    avgResponseTime: stressTester.responseTimes.reduce((a, b) => a + b, 0) / stressTester.responseTimes.length,
                    currentRPS: stressTester.currentRPS
                },
                chartData: stressTester.testData
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `stress-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>